\documentclass{scrartcl}

\usepackage{graphicx}
\usepackage{minted}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage[margin=1.0in]{geometry}
\usepackage{multicol}
\usepackage{titlesec}
\usepackage{filecontents}
\usepackage{url}

\definecolor{secblue}{rgb}{0.18, 0.27, 0.33}

\input{style.tex}

\pagestyle{plain}

\title{DuckTest}
\subtitle{{\textcolor{bardark}{A Brief Tour of Static Duck Type Checking for Python}}}
\author{Joshua Rahm \\
\footnotesize Department of Computer Science \\[2pt]
\footnotesize University of Colorado}
\date{}


\begin{filecontents}{bib.bib}
@misc{logic,
  author = {Ravi Chugh, Patrick M. Rondon, Ranjit Jhal},
  title = {{Nested Refinements: A Logic for Duck Typing}},
  howpublished = "\url{http://people.cs.uchicago.edu/~rchugh/static/papers/popl12-nested.pdf}",
  note = "[Online; accessed 10-November-2015]"
}

@misc{nst,
  title = {{Nomitive and Structural Typing}},
  howpublished = "\url{http://c2.com/cgi/wiki?NominativeAndStructuralTyping}",
  note = "[Online; accessed 13-November-2015]"
}

@misc{dynamic,
  author = {Jonathan Eifrig, Scott Smith, Valery Trifonov},
  title = {{Type Inference for Recursively Constrained Types and its Application to OOP}},
  howpublished = "\url{http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=F4F3BAF0FC6AB2A0681AA4428CFD4C4A?doi=10.1.1.92.6519&rep=rep1&type=pdf}",
  note = "[Online; accessed 13-November-2015]"
}
\end{filecontents}


\begin{document}
\nocite{*}
\maketitle
\hrule

% \raggedcolumns
\begin{multicols}{2}
% \raggedcolumns

\begin{abstract}
    Dynamic typing is a very hot field right now. It decreases the amount
    of work needed to complete simple tasks. Without doubt, dynamic languages
    have flexibility that is unmatched by any statically typed language no
    matter how powerful the type system. This flexibility comes at a cost, however.
    Namely in static analysis, particularly type verifiers. The lack of a static
    type system can lead to very onerous errors at runtime. This is where DuckTest
    comes in. DuckTest is a Python static analyzer that uses Data Flow Analysis
    and Type inference to detect TypeErrors statically while retaining as
    much flexibility as possible.
\end{abstract}

\section*{Introduction}

The duck test refers to the ever so popular statement ``If it looks like a duck,
swims like a duck, and quacks like a duck, then it probably is a duck.'' While
no sound logic for formal proofs, this type of logic has found its way into some
of the most popular programming languages today. These ``Duck'' type systems allow
an object $o_1$ to act as some type $t_1$ if $o_1$ implements all the features of
that type regardless of what the named type of $o_1$ actually is.

This type system makes is very flexible and allows the programmer to use
different types under the same context. Contrary to what many programmers
think, a duck type system is not synonomous with a \emph{dynamic} type
system, but the two are often together.

DuckTest is an application employing techniques such as Data Flow Analysis and
Type Inference to statically screen Python source code for potential type errors.
Currently DuckTest only supports a relatively limited subset of Python, but
extensions and improvements will continue to be added. DuckTest operates on Python,
but it itself is written in Haskell, rather than Python. This is a huge advantage
of DuckTest over other ``lint'' checkers because Haskell is very well suited for
this static program analysis and is also free of type errors at runtime.


\section*{Motivation}

Python and other dynamically typed languages are very useful tools to solve a
wide range of different problems. While these languages are very flexible and
very quick to prototype in, their very dynamic style makes it very difficult
for static analyzers to properly check the source for what one would consider
obvious errors.

Errors in dynamically typed languages can be notoriously onerous. This is
because a programmer may introduce a type error well before that type error
actually gets raised! Since these type errors are raised one at a time, to
find them you must run the program, potentially until the very end to find
type errors and debug them. For many programmers, this is simply out of the
question. This relentless and monotonous loop of run, crash, debug, fix is
enough to drive any programmer up the wall.

Yet there is a discrepancy here. Type errors most of the time happen from
a mistake by the programmer where an object was erroneously constructed (is
x supposed to be a list of tuples or a tuple of lists?) or where the programmer
accidentally leaves a function unimplemented, etc. The fact is, programmers
still tend to write dynamic code as they would static code, just without the
type annotations. If programmers can keep track of the attributes and avoid
writing erroneous code this way, why can't a machine do that and save us all
the time?

The answer is ``it's complicated.'' While indeed there are elements of Python
that are easy to check, what becomes insidious is the dynamism of the language
itself, particularly, the ability to check and change virtually anything at
runtime, for this reason, DuckTest has implemented one major restriction;
in order to reduce the number of false positives, the programmer must program
in a way that is consistent with \emph{Type Erasure Semantics}. Type Erasure
Semantics is a programming style that does not rely on type information at
runtime. In the context of Python, this means no dynamically changing the contents
of a class.

Even though DuckTest does recognize conditional branching based on the \emph{hasattr}
function and class equality and can adjust accordingly, it is highly recommended
not to this as it can confuse type checkers.

\section*{The Algorithm}

In order for type inference and checking to work in Python, it is paramount
to create a model for Python types that will allow the algorithm to reason
about types in a structured and consistent matter.

\subsection*{The Type Model}

There is a type system called \emph{Structural Typing}. A Structural
Type System is a system that uses an object's attributes as the identifier
of its type contrary to the majority of statically typed languages that
use some other characteristic like the name of the type.

A Structural Type model is an appealing way to model the types in Python
since in a structural type system, an object $o_1$ is compatible with
an object $o_2$ if $o_1$ implements all the attributes of the object $o_2$.
This attribute is very similar to how duck typing operates.

Structural Typing alone will not work as a model because it is too restrictive
in terms of lacking ways to model recursive types and function types; however,
the benefits are clear, which is why DuckTest uses a similar type model,
but with some changes.

In the source for DuckTest, there is a data structure used to represent
the types in python called \emph{PyType}. The PyType is a simple Algebraic
Data Type that follows the signature:

\begin{minted}{haskell}
data PyType = Scalar
                (Maybe String)
                (Map String PyType)
            | Functional
                [PyType]
                PyType
            | Alpha
                String
                PyType
            | Any
            | Void
\end{minted}

\subsubsection*{Scalar Type}

\mintinline{haskell}{Scalar (Maybe String) (Map String PyType)}

Under this model, scalars are the most common type. They alone are
the model of structural types. They contain an optional type name
(for debugging and error messages) and a mapping between attribute
names and associated types.

\subsubsection*{Functional Types}

\mintinline{haskell}{Functional [PyType] PyType}

A functional type is, quite obviously, a type representing functions.
Since python doesn't support currying, the functional type is implemented
as a basic procedural function type, that takes some arguments and returns
some other type. Python has the concept of varadic arguments, currently,
these are not modeled along with keyword and positional arguments.

\subsubsection*{Alpha Types}

\mintinline{haskell}{Alpha String PyType}

The alpha type is an interesting concept borne out of trial and error. The
alpha type is used for recursive types. It is Essentially a marker so
the checking algorithm terminates properly. Consider the example of
a LinkedList. Under a purely structural model, this type may not be represented
since the type inferencer would never terminate as the type
would look something like

\vspace{0.2cm}
$LinkedList = \{data::Any,next::\{data::Any,next::\{data::Any,next::\{\ldots\}\}\}\}$
\vspace{0.2cm}

This is where the alpha type comes in. Under this system
a LinkedList would have the type

\vspace{0.2cm}
$LinkedList = \{data::Any,next::alpha LinkedList\}$.
\vspace{0.2cm}

Alpha types exist purely as a pragmatic guard. The formal type algebra does
not need them, but that is simply because the formal algebra does not need
to concern itself with termination.

\subsubsection*{Any}

The Any type is an important concept. It has a dual role.  It behaves like the
infinite scalar. That is, the scalar with all possible attributes all of which
have the Any type themselves. This means the Any type is structurally compatible
with everything; however, the second role is that of the empty scalar, making
everything compatible as it. Essentially, the Any type is a wild card; it matches
everything and everything matches it.

\subsubsection*{Void}

The Void type, while important, is actually redundant. It is exactly equal to the
empty scalar. That is, the scalar with no attributes. Everything is compatible
as it, but it is only compatible as itself. Under strict rules, this would be the
type of \emph{None} since it cannot act as anything without crashing. However,
since \emph{None} is entrenched as an integral part of Python, it semantically
has the Any type.

Void is still very important as the type returned from functions lacking a return
type, as well as being effectively a zero to the algebra.


\subsection*{The Algebra}

I mentioned a couple of times in the previous section about an algebra for these types.
The algebra is an extremely important semantic to dealing with tracing the
types of variables throughout the program.

There are three primary operators from which the rest of the algebra is formed;
\emph{union, intersection, and difference}.

These three operators under this model are the basic tools used to infer and check
the types.

\subsubsection*{Union}

The union operator in the PyType algebra is the operator that takes
two types $t_1$ and $t_2$ and returns a type $t_3$ such that $t_3$ can
act as either $t_1$ or $t_2$.

The key to the union type is that the type returned can itself match more
types, and can be used in more locations, but, it is also more difficult
to match against that type. This makes sense since $t_3$ is guaranteed
to have at least the number of attributes as its constituents.

The definition of union for scalars is fairly straightforward, it simply
recursively unions all the attributes of $t_1$ and $t_2$. So if

$t_1 = \{a :: A, b :: B_1, c :: C_1\}$

and

$t_2 = \{c :: C_2, b :: B_2, d :: D\}$

then

$t_1 \cup_r t_2 = \{a :: A, b :: B_1 \cup_r B_2, c :: C_1 \cup_r C_2, d :: D\}$

For other types of types, it gets a little stranger. For example, the union
of two functions is actually the \emph{intersection} of the parameter types
and the union of the return types. The theory behind this is discussed later
in the paper.

\bibliographystyle{abbrv}
\bibliography{bib}

\vspace{\textheight}
\end{multicols}
\end{document}
